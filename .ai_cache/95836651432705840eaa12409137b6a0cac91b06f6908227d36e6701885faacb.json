{"mtime": 1764171475.158532, "text": "DBMS Instances and Processes\nDBMS Lecture Series\nUnit-4\nDr. Pavinder Yadav\nAssistant Professor\nSchool of Computer Science\nUniversity of Petroleum and Energy Studies\nDehradun\nDr. Pavinder Yadav (UPES) Unit 4 1 / 32\nOutline\n1 DBMS Instance\n2 DBMS Internal Memory Structure\n3 Background Processes\nDr. Pavinder Yadav (UPES) Unit 4 2 / 32\nTable of Contents\n1 DBMS Instance\n2 DBMS Internal Memory Structure\n3 Background Processes\nDr. Pavinder Yadav (UPES) Unit 4 3 / 32\nIntroduction to DBMS Instance\nLearning Objectives\nUnderstand what a DBMS Instance is.\nDifferentiate between a Database and an Instance.\nExplore how an instance works internally (Memory + Processes).\nDefinition\nA DBMS Instance is a collection of memory structures and background processes that\nmanage access to the database files stored on disk.\nDr. Pavinder Yadav (UPES) Unit 4 4 / 32\nDatabase vs Instance\nDatabase:\nPhysical data stored on disk.\nIncludes data files, control files, log files.\nStatic and persistent.\nInstance:\nActive set of memory + processes.\nHandles queries and transactions.\nExists only while DBMS is running.\nExamples\nAnalogy: The database is like a library of books , while the instance is the librarian who\nretrieves and manages the books.\nDr. Pavinder Yadav (UPES) Unit 4 5 / 32\nComponents of a DBMS Instance\nTwo Major Parts\nMemory Structures: Buffer cache, log buffer, shared pool, etc.\nBackground Processes: Perform I/O, recovery, and transaction control.\nKey Idea\nEvery running DBMS server (like mysqld or Oracle instance ) is an instance. Stopping the\nservice terminates the instance, but the database (data files) remains.\nDr. Pavinder Yadav (UPES) Unit 4 6 / 32\nInstance Lifecycle\nPhases of an Instance\n1 STARTUP: Allocates memory, starts background processes.\n2 MOUNT: Reads control files and prepares access to data files.\n3 OPEN: Database available for user connections.\n4 SHUTDOWN: Writes final logs, releases memory.\nExamples\nIn Oracle, use:\nSTARTUP \u2013 to start instance.\nSHUTDOWN IMMEDIATE \u2013 to stop instance.\nDr. Pavinder Yadav (UPES) Unit 4 7 / 32\nMultiple Instances and Clusters\nSingle vs Multiple Instances\nUsually, one instance per database.\nIn cluster systems (e.g. Oracle RAC ), multiple instances can access the same database\nfiles.\nAdvantage\nMultiple instances improve scalability and fault tolerance for high-availability systems.\nExamples\nExample: Two instances of Oracle access the same set of datafiles in a Real Application\nCluster (RAC) environment.\nDr. Pavinder Yadav (UPES) Unit 4 8 / 32\nReal-World Example: MySQL Instance\nWhen you start MySQL Server:\nMemory allocated: Buffer pool, log buffer,\nquery cache.\nThreads started: I/O, log, background\nthreads.\nCommands:\nSHOW VARIABLES LIKE 'version';\nSHOW ENGINE INNODB STATUS;\nRestart service \u2192 restarts instance.\nExamples\nMySQL\u2019s mysqld process = DBMS instance running in RAM.\nDr. Pavinder Yadav (UPES) Unit 4 9 / 32\nSummary\nKey Takeaways\nA DBMS Instance = memory + processes managing the database.\nA Database = stored data files on disk.\nInstances are temporary; databases are persistent.\nCheckpoint Question\nQuestion: What happens when you stop a DBMS instance?\nAnswer: The data on disk remains intact, but users lose access until the instance restarts.\nDr. Pavinder Yadav (UPES) Unit 4 10 / 32\nTable of Contents\n1 DBMS Instance\n2 DBMS Internal Memory Structure\n3 Background Processes\nDr. Pavinder Yadav (UPES) Unit 4 11 / 32\nIntroduction to Memory Structure\nLearning Objectives\nUnderstand how memory is organized inside a running DBMS instance .\nLearn about shared memory areas and private process memory .\nExplore how caches and buffers improve performance.\nDefinition\nThe DBMS Internal Memory Structure refers to all the memory areas used by the DBMS\nto process queries, cache data, and maintain transaction logs while the instance is running.\nDr. Pavinder Yadav (UPES) Unit 4 12 / 32\nPurpose of Memory Structures\nMain Purposes\nStore data temporarily while queries execute.\nCache frequently accessed disk blocks.\nBuffer log entries before writing to disk.\nManage sorting, joining, and aggregation operations.\nExamples\nAnalogy: If the database is a bookshelf, memory areas are the table and notes where we work\ntemporarily before returning books.\nDr. Pavinder Yadav (UPES) Unit 4 13 / 32\nTypes of Memory Areas\nTwo Major Types\nSystem (Shared) Memory \u2014 Common workspace for all sessions.\nProcess (Private) Memory \u2014 Dedicated memory per user session.\nKey Difference\nShared memory enables inter-process communication , while private memory ensures session\nisolation.\nDr. Pavinder Yadav (UPES) Unit 4 14 / 32\nShared Memory Components\nMain Components\nBuffer Cache (Data Cache) \u2013 Holds copies of data blocks from disk.\nLog Buffer \u2013 Temporary area for transaction redo information.\nShared Pool \u2013 Stores parsed SQL statements and data dictionary.\nLarge Pool / Java Pool \u2013 Used for backups, Java procedures, or streams.\nExamples\nWhen the same query runs again, DBMS can reuse the parsed plan from the Shared Pool\ninstead of reparsing it.\nDr. Pavinder Yadav (UPES) Unit 4 15 / 32\nPrivate (Per-Process) Memory Areas\nProgram Global Area (PGA) \u2013 Each process\u2019s\nprivate workspace.\nSort Area / Hash Area \u2013 Temporary area for\njoins, GROUP BY, ORDER BY.\nSession Memory \u2013 Stores user variables, cursors,\nand state.\nExamples\nDuring a big ORDER BY , the\ntemporary sorted data is held in the\nSort Area before being returned to\nthe user.\nDr. Pavinder Yadav (UPES) Unit 4 16 / 32\nOverall Memory Layout\nSimplified Architecture\n+-------------------------------------------------------------+\n| DBMS INSTANCE (Memory + Processes) |\n|-------------------------------------------------------------|\n| SHARED GLOBAL AREA (SGA) |\n| + Shared Pool | Buffer Cache | Log Buffer | Large Pool |\n|-------------------------------------------------------------|\n| PROCESS GLOBAL AREAS (PGA) |\n| + Session 1 | Session 2 | Session 3 ... |\n+-------------------------------------------------------------+\nInterpretation\nThe SGA is common for all connections; each user has their own PGA.\nDr. Pavinder Yadav (UPES) Unit 4 17 / 32\nExample: MySQL InnoDB Memory\nKey Memory Areas:\nBuffer Pool \u2013 caches data and index pages.\nRedo Log Buffer \u2013 stores redo entries before\nflushing to log files.\nSort / Join Buffers \u2013 created per session.\nUseful Commands:\nSHOW VARIABLES LIKE\n'innodb_buffer_pool_size';\nSHOW ENGINE INNODB STATUS\\G;\nExamples\nThese commands reveal how much memory MySQL allocates for caching and transaction logs.\nDr. Pavinder Yadav (UPES) Unit 4 18 / 32\nPerformance Importance\nWhy Memory Matters\nReduces disk I/O by caching frequently accessed data.\nEnables faster query execution through optimized sorting and joins.\nEnsures durability via log buffering before commit.\nCommon Issue\nIf the buffer cache is too small, the system experiences cache misses and frequent disk reads,\nslowing down performance.\nDr. Pavinder Yadav (UPES) Unit 4 19 / 32\nHands-on Observation\nIn MySQL:\nSHOW ENGINE INNODB STATUS\\G;\nView buffer pool and background thread stats.\nIn Oracle:\nSHOW SGA;\nDisplays total shared memory usage\nand cache sizes.\nExamples\nStudents can compare the memory allocation of MySQL and Oracle to understand real-world\nimplementation of DBMS instances.\nDr. Pavinder Yadav (UPES) Unit 4 20 / 32"}